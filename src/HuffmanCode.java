import java.io.Serializable;
import java.util.*;

public class HuffmanCode implements Serializable {
    private static final long serialVersionUID = 1L;

    private Map<Character, String> huffmanMap;
    private HuffmanNode rootNode;
    private int encodedLength;

    public HuffmanCode() {
        this.rootNode = new HuffmanNode();
        this.huffmanMap = new HashMap<>();
    }

    public HuffmanCode(HuffmanNode rootNode) {
        this.rootNode = rootNode;
    }

    public void setEncodedLength(int encodedLength) { this.encodedLength = encodedLength; }

    public void buildHuffmanTree(Map<Character, Integer> characterFrequencyTable) {
        PriorityQueue<HuffmanNode> queue = new PriorityQueue<>(characterFrequencyTable.size(), new Comparator<HuffmanNode>() {
            @Override
            public int compare(HuffmanNode o1, HuffmanNode o2) {
                return o1.getFreq() - o2.getFreq();
            }
        });

        for (Map.Entry<Character, Integer> entry : characterFrequencyTable.entrySet()) {
            HuffmanNode newNode = new HuffmanNode(entry.getKey(), entry.getValue());

            queue.add(newNode);
        }

        HuffmanNode rootNode = null;
        while (queue.size() > 1) {
            HuffmanNode x = queue.peek();
            queue.poll();

            HuffmanNode y = queue.peek();
            queue.poll();

            HuffmanNode f = new HuffmanNode();

            f.setFreq(x.getFreq() + y.getFreq());
            f.setZero(x);
            f.setOne(y);

            rootNode = f;

            queue.add(f);
        }

        this.huffmanMap.clear();
        buildHuffmanMap(rootNode, "");
        printCode(rootNode, "");
        this.rootNode = rootNode;
    }

    public void decodeHuffmanCode(String data) {
        // decode and return decoded data
    }

    public HuffmanNode getRootNode() { return this.rootNode; }
    public Map<Character, String> getHuffmanReferenceTable() { return this.huffmanMap; }

    private void addReference(char huffmanChar, String huffmanCode) {
        this.huffmanMap.put(huffmanChar, huffmanCode);
    }

    private void buildHuffmanMap(HuffmanNode root, String s) {
        if (root == null) return;

        if (root.getZero() == null && root.getOne() == null) {
            this.huffmanMap.put(root.getC(), s);
            return;
        }

        buildHuffmanMap(root.getZero(), s + "0");
        buildHuffmanMap(root.getOne(), s + "1");
    }

    public String decode(byte[] byteArray) {
        String huffmanStringToDecode = byteArrayToString(byteArray);
        String decompressedString = "";

        int i = 0;
        HuffmanNode currentNode = this.rootNode;
        while (i < this.encodedLength) {
            char c = huffmanStringToDecode.charAt(i);
            if (currentNode.isLeaf()) {
                decompressedString += currentNode.getC();
                System.out.print(currentNode.getC());
                currentNode = this.rootNode;
            } else {
                if (c == '0') currentNode = currentNode.getZero();
                else if (c == '1') currentNode = currentNode.getOne();
                i++;
            }
        }
        System.out.println(decompressedString);
        return decompressedString;
    }

    public String byteArrayToString(byte[] byteArray) {
        StringBuilder huffmanString = new StringBuilder();
        for (byte b : byteArray) {
            huffmanString.append(String.format("%8s", Integer.toBinaryString(b & 0xFF)).replace(' ', '0'));
        }

        return huffmanString.toString().substring(0, this.encodedLength);
    }

    /// JUSTE VISUEL
    public void printCode(HuffmanNode root, String s) {

        // base case; if the left and right are null
        // then its a leaf node and we print
        // the code s generated by traversing the tree.
        if (root.getZero() == null && root.getOne() == null) {

            // c is the character in the node
            System.out.println(root.getC() + ":" + s);

            return;
        }

        // if we go to left then add "0" to the code.
        // if we go to the right add"1" to the code.

        // recursive calls for left and
        // right sub-tree of the generated tree.
        if (root != null) {
            printCode(root.getZero(), s + "0");
            printCode(root.getOne(), s + "1");
        }
    }
}
