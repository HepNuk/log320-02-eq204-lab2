import java.io.Serializable;
import java.util.*;

public class HuffmanCode implements Serializable {
    private Map<Character, String> huffmanMap;
    private HuffmanNode rootNode;

    public HuffmanCode () {
        this.rootNode = new HuffmanNode();
        this.huffmanMap = new HashMap<>();
    }

    public void encodeHuffmanCode(Iterator<Character> iterator, String huffmanValue, HuffmanNode currentNode) {
        Character current = iterator.next();

        if (!iterator.hasNext()) {
            huffmanMap.put(current, huffmanValue + "0");
//            currentNode.setZero(new HuffmanNode(current));
        } else {
            huffmanMap.put(current, huffmanValue + "1");
//            currentNode.setOne(new HuffmanNode(current));
            currentNode.setZero(new HuffmanNode());
            currentNode = currentNode.getZero();

            encodeHuffmanCode(iterator, huffmanValue + "0", currentNode);
        }
    }

    public void encodeHuffmanCode2(Map<Character, Integer> characterFrequencyTable) {
        HuffmanNode currentNode = null;
        HuffmanNode sideNode = null;

        for (Map.Entry<Character, Integer> entry : characterFrequencyTable.entrySet()) {
            char c = entry.getKey();
            int freq = entry.getValue();

            if (currentNode == null) {
                currentNode = new HuffmanNode(c, freq);
            } else if (currentNode.getFreq() > freq) {
                HuffmanNode newHuffmanCharNode = new HuffmanNode(c, freq);
                HuffmanNode newHuffmanNode = new HuffmanNode(currentNode.getFreq() + freq, currentNode, newHuffmanCharNode);
                currentNode = newHuffmanNode;
            } else if (currentNode.getFreq() <= freq) {
                if (sideNode == null) {
                    sideNode = currentNode;
                    currentNode = new HuffmanNode(c, freq);
                } else if (sideNode.getFreq() <= freq) {

                }
            }
        }
    }

    public void buildHuffmanTree(Map<Character, Integer> characterFrequencyTable) {
        PriorityQueue<HuffmanNode> queue = new PriorityQueue<>(characterFrequencyTable.size(), new Comparator<HuffmanNode>() {
            @Override
            public int compare(HuffmanNode o1, HuffmanNode o2) {
                return o1.getFreq() - o2.getFreq();
            }
        });

        for (Map.Entry<Character, Integer> entry : characterFrequencyTable.entrySet()) {
            HuffmanNode newNode = new HuffmanNode(entry.getKey(), entry.getValue());

            queue.add(newNode);
        }

        HuffmanNode rootNode = null;
        while (queue.size() > 1) {
            HuffmanNode x = queue.peek();
            queue.poll();

            HuffmanNode y = queue.peek();
            queue.poll();

            HuffmanNode f = new HuffmanNode();

            f.setFreq(x.getFreq() + y.getFreq());
            f.setZero(x);
            f.setOne(y);

            rootNode = f;

            queue.add(f);
        }

        this.huffmanMap.clear();
        buildHuffmanMap(rootNode, "");
    }

    public void decodeHuffmanCode(String data) {
        // decode and return decoded data
    }

    public HuffmanNode getRootNode() { return this.rootNode; }
    public Map<Character, String> getHuffmanReferenceTable() { return this.huffmanMap; }

    private void addReference(char huffmanChar, String huffmanCode) {
        this.huffmanMap.put(huffmanChar, huffmanCode);
    }

    private void buildHuffmanMap(HuffmanNode root, String s) {
        if (root.getZero() == null && root.getOne() == null) {
            this.huffmanMap.put(root.getC(), s);
            return;
        }

        if (root != null) {
            buildHuffmanMap(root.getZero(), s + "0");
            buildHuffmanMap(root.getOne(), s + "1");
        }
    }

    public void printCode(HuffmanNode root, String s) {

        // base case; if the left and right are null
        // then its a leaf node and we print
        // the code s generated by traversing the tree.
        if (root.getZero() == null && root.getOne() == null) {

            // c is the character in the node
            System.out.println(root.getC() + ":" + s);

            return;
        }

        // if we go to left then add "0" to the code.
        // if we go to the right add"1" to the code.

        // recursive calls for left and
        // right sub-tree of the generated tree.
        if (root != null) {
            printCode(root.getZero(), s + "0");
            printCode(root.getOne(), s + "1");
        }
    }

    // Private methods
}
